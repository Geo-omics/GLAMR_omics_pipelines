#!/usr/bin/env python3
"""
Guess the amplicon target based on summaries of hmmscan
"""
import argparse

from amplicon_regions import coordinates


# read directions
FWD = 'fwd'
REV = 'rev'


argp = argparse.ArgumentParser(description=__doc__)
argp.add_argument(
    'summary',
    nargs='+',
    type=argparse.FileType(),
    help='One or more paths to summarized nhmmscan results, as made by the '
         'summarize_nhscan script.  For paired-end sequencing two files should'
         'be provided, the first being for the forward reads and the second '
         'for the reverse reads.',
)
argp.add_argument(
    '--output',
    help='Path to output file.  If missing, then output will be printed to '
         'stdout',
)

args = argp.parse_args()

NO_HITS = object()


def get_summary(ifile):
    """
    Parse summary file

    ifile: file handle, opened for reading
    """
    head = ifile.readline().rstrip('\n').split('\t')
    line = ifile.readline().rstrip('\n')

    if not line:
        # no hits at all
        return {NO_HITS: True}

    row = {}
    for colname, value in zip(head, line.split('\t')):
        if colname == 'n_seqs' or colname.endswith('_median'):
            try:
                value = int(value)
            except ValueError:
                try:
                    value = float(value)
                except Exception as e:
                    argp.error(f'failed parsing: {e} {line=}')
            except Exception as e:
                argp.error(f'failed parsing: {e} {line=}')
        row[colname] = value
    return row


def check_paired_end(fwd, rev):
    """
    Check data and write to output file
    """
    # Thresholds.  These values are the limits where the top hmm summary pick
    # still seems to give a good guess
    MIN_N_SEQS = 200
    MAX_E_VAL = 1e-40
    MIN_SCORE = 128

    critical = []
    errors = []
    infos = []
    no_hits = False

    n_seqs = []
    e_val = []
    score = []
    for data in (fwd, rev):
        if NO_HITS in data:
            critical.append(f'no hits: {data["direction"]}')
            no_hits = True
            continue

        n_seqs.append(data['n_seqs'])
        e_val.append(data['e_value_median'])
        score.append(data['score_median'])

        if data['n_seqs'] < MIN_N_SEQS:
            critical.append(
                f'too low: {data["direction"]}: n_seqs={data["n_seqs"]}'
            )
        if data['e_value_median'] > MAX_E_VAL:
            critical.append(
                f'too high: {data["direction"]}: e_value_median='
                f'{data["e_value_median"]}'
            )
        if data['score_median'] < MIN_SCORE:
            critical.append(
                f'too low: {data["direction"]}: score_median='
                f'{data["score_median"]}'
            )

    if no_hits:
        tax_group = None
        gene = None
        regions = []
        overlap = None
        gap = None
        swapped = None
        n_seqs = 0
    else:
        n_seqs = min(n_seqs)
        e_val = max(e_val)
        score = min(score)

        # Below analysis only makes sense if we've got hits for both read
        # directions
        if (fwd['tax_group'], fwd['gene']) == (rev['tax_group'], rev['gene']):
            gene = fwd['gene']
            tax_group = fwd['tax_group']
        else:
            gene = None
            tax_group = None
            critical.append('gene disagreement between fwd and rev')

        # checking seq start/end:
        fwd_is_fwd = fwd['seq_start_median'] < fwd['seq_end_median']
        rev_is_rev = rev['seq_start_median'] > rev['seq_end_median']

        swapped = False
        if fwd_is_fwd and rev_is_rev:
            # all is in order
            pass
        elif not fwd_is_fwd and not rev_is_rev:
            # directions got mixed up -- make a note, but is not an error
            swapped = True
        else:
            # what a mess
            errors.append('seq start/end and read directions messed up!')

        fwd_sta = fwd['hmm_start_median']
        fwd_end = fwd['hmm_end_median']
        rev_sta = rev['hmm_start_median']
        rev_end = rev['hmm_end_median']

        if fwd_sta > fwd_end:
            errors.append('bad fwd coords (start must come before end)')
        if rev_sta > rev_end:
            errors.append('bad rev coords (start must come before end)')

        if fwd_end < rev_sta or rev_end < fwd_sta:
            infos.append('fwd and rev reads do not overlap')

        # detect regions
        regions = []
        missed_via_gap = []
        in_gap_temp = []
        region_data = coordinates.get((tax_group, gene), {})
        for region, (start, end) in region_data.items():
            fwd_miss = fwd_end < start or end < fwd_sta
            rev_miss = rev_end < start or end < rev_sta
            if fwd_miss and rev_miss:
                # total miss
                if regions:
                    in_gap_temp.append(region)
                pass
            else:
                if in_gap_temp:
                    regions += in_gap_temp
                    missed_via_gap += in_gap_temp
                    in_gap_temp = []

                # counting any sort of overlap as hitting the region
                regions.append(region)

        # calculate overlap/gap
        single_cov = (min(fwd_sta, rev_sta), max(fwd_end, rev_end))
        both_cov = (max(fwd_sta, rev_sta), min(fwd_end, rev_end))
        if both_cov[0] <= both_cov[1]:
            gap = None
            overlap = (both_cov[1] - both_cov[0]) / (single_cov[1] - single_cov[0])  # noqa:E501`
        else:
            gap = both_cov[0] - both_cov[1]
            overlap = 0.0

        if missed_via_gap:
            infos.append(f'regions in gap: {",".join(missed_via_gap)}')
            if not gap:
                raise RuntimeError('logic bug, missing a region implies a gap')

    infos.append(f'n_seqs={n_seqs}')

    if not no_hits:
        infos.append(f'eval={e_val:.1g}')
        infos.append(f'score={score:.0f}')
        if tax_group and gene:
            # info below only makes sense if hits agree on the gene and
            # tax_group
            if swapped:
                infos.append(f'fwd_start={rev_sta:.0f}')
                infos.append(f'fwd_end={rev_end:.0f}')
                infos.append(f'rev_start={fwd_sta:.0f}')
                infos.append(f'rev_end={fwd_end:.0f}')
            else:
                infos.append(f'fwd_start={fwd_sta:.0f}')
                infos.append(f'fwd_end={fwd_end:.0f}')
                infos.append(f'rev_start={rev_sta:.0f}')
                infos.append(f'rev_end={rev_end:.0f}')
        if critical:
            if tax_group and gene:
                infos.append(f'tax/gene={tax_group}/{gene}')
            else:
                infos.append(
                    f'tax/gene={fwd["tax_group"]}/{fwd["gene"]}'
                    f'<->{rev["tax_group"]}/{rev["gene"]}'
                )

    output = {
        'tax_group': tax_group or '',
        'gene': gene or '',
        'regions': ','.join(regions),
        'overlap': '' if overlap is None else f'{overlap:.2%}',
        'gap': '' if gap is None else str(gap),
        'dirs_swapped': 'swapped' if swapped else '',
    }
    outlines = ['\t'.join(output.keys()) + '\n']
    if critical:
        errors = critical + [f'[withheld guess] {output}'] + errors
    else:
        outlines.append('\t'.join(output.values()) + '\n')
    for err in errors:
        outlines.append(f'# [ERROR] {err}\n')
    for info in infos:
        outlines.append(f'# [INFO] {info}\n')

    outtxt = ''.join(outlines)

    if args.output:
        with open(args.output, 'w') as ofile:
            ofile.write(outtxt)
    else:
        print(outtxt, end='')


# MAIN
if len(args.summary) == 2:
    fwd_data = get_summary(args.summary[0])
    fwd_data['direction'] = FWD
    rev_data = get_summary(args.summary[1])
    rev_data['direction'] = REV
else:
    argp.error('expecting two input files.  Processing single-end sequencing '
               'data is not implemented.')


# Part 2 -- checks and balances
check_paired_end(fwd_data, rev_data)
